# 네이티브

## 3.1 내부 [[Class]]
typeof가 'object'인 값(배열 등)에는 [[Class]]라는 

## 3.2 래퍼 박싱하기

오래전부터 브라우저는 이런 흔한 경우를 스스로 최적화하기 때문이다. 개발자가 직접 객체 형태로 선 최적화하면 프로그램이 더 느려질 수 있다. 그러니 new String("abc"), new Number(42) 처럼 코딩하지 말고, 그냥 알기 쉽게 원시 값 "abc", 42를 사용하자.

### 3.2.1 객체 래퍼의 함정

## 3.3 언박싱
객체 래퍼의 원시 값은 valueOf() 메서드로 추출한다.

## 3.4 네이티브, 나는 생성자다

### 3.4.4 Symbol()

심벌은 ES6에서 처음 선보인 새로운 원시 값 타입이다. 심벌은 충돌 염려 없이 객체 프로퍼티로 사용 가능한 특별한 '유일 값'이다.

## 3.5 정리하기
자바스크립트는 원시 값을 감싸는 객체 래퍼, 즉 네이티브를 제공한다. 객체 래퍼에는 타입별로 쓸 만한 기능이 구현되어 있어 편리하게 사용할 수 있다.

"abc"같은 단순 스칼라 원시 값이 있을 때, 이 값의 length 프로퍼티나 String.prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시 값을 '박싱'(해당되는 객체 래퍼로 감싼다)하여 필요한 프로퍼티와 메서드를 쓸 수 있게 도와준다.


## 질문 & 중요
* 77p : ``Function 생성자는 함수의 인자나 내용을 동적으로 정의해야 하는 매우 드문 경우에 한해 유용하다. Function()을 eval()의 대용품이라고 착각하지 말자. 이렇게 함수를 동적으로 정의할 일은 아마 거의 없을 것이다.``
  * -> 언제 인자나 내용을 동적으로 정의해야 하지?
* 77p : 정규 표현식은 리터럴 형식(/^a*b+/g)으로 정의할 것을 적극 권장한다. RegExp()는 정규 표현식 패턴을 동적으로 정의할 경우 의미있는 유틸리티이다.
* 79p : Symbol() 심벌은 ES6에서 처음 선보인, 새로운 원시 타입이다. 심벌은 염려 없이 객체 프로퍼티로 사용 가능한, 특별한 '유일 값'이다(절대적으로 유일함을 보장하지는 않음).
* 82p : 프로토타입으로 디폴트 값을 세팅하면 사소하지만 추가적인 이점이 있다. .prototype들은 이미 생성되어 내장된 상태이므로 단 한 번만 생성된다. 그러나 ``[], function(){}, /(?:)/``를 디폴트 값으로 사용하면 isThisCool()를 호출할 때마다 디폴트 값을 다시 생성하므로 그만큼 메모리/CPU가 낭비된다.
* 정규표현식 구현 알고리즘이 어떻게 만들어져 있나?
  * 내가 구현한거 vs 정규표현식

* 프로토타입 개념과 프로토타입 체이닝에 대해 잘 설명한 [글](https://medium.com/@pks2974/javascript-%EC%99%80-prototype-%ED%94%84%EB%A1%9C%ED%86%A0-%ED%83%80%EC%9E%85-515f759bff79)

* ``Object.defineproperty()``의 writable:false로 하는 것과 Symbol을 쓰는 것의 차이는 무엇인가요? 
  * [Object.defineproperty() MDN Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

